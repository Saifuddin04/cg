Develop an OpenGL program to Clip 2D lines using Cohen- Sutherland algorithm.
#include <GL/glut.h>
#include <iostream>
// Define region codes for Cohen-Sutherland algorithm
const int INSIDE = 0; // 0000
const int LEFT = 1; // 0001
const int RIGHT = 2; // 0010
const int BOTTOM = 4; // 0100
const int TOP = 8; // 1000
float x_min = 50, y_min = 50, x_max = 200, y_max = 200; // Clipping window
float x0 = 25, y0 = 125, x1 = 150, y1 = 250; // Line endpoints
int computeCode(float x, float y) {
int code = INSIDE; // Initialize as inside
if (x < x_min) // to the left of rectangle
code |= LEFT;
else if (x > x_max) // to the right of rectangle
code |= RIGHT;
if (y < y_min) // below the rectangle
code |= BOTTOM;
else if (y > y_max) // above the rectangle
code |= TOP;
return code;
}
void cohenSutherlandLineClip() {
int code0 = computeCode(x0, y0);
int code1 = computeCode(x1, y1);
bool accept = false;
while (true) {
if (!(code0 | code1)) { // Both endpoints inside the rectangle
accept = true;
break;
} else if (code0 & code1) { // Both endpoints outside the rectangle and same region
break;
} else {
int codeOut = code0 ? code0 : code1; // Find the code of the point outside
float x, y;
if (codeOut & TOP) { // Point is above the clip rectangle
x = x0 + (x1 - x0) * (y_max - y0) / (y1 - y0);
y = y_max;
} else if (codeOut & BOTTOM) { // Point is below the clip rectangle
x = x0 + (x1 - x0) * (y_min - y0) / (y1 - y0);
y = y_min;

} else if (codeOut & RIGHT) { // Point is to the right of clip rectangle
y = y0 + (y1 - y0) * (x_max - x0) / (x1 - x0);
x = x_max;
} else if (codeOut & LEFT) { // Point is to the left of clip rectangle
y = y0 + (y1 - y0) * (x_min - x0) / (x1 - x0);
x = x_min;
}
if (codeOut == code0) {
x0 = x;
y0 = y;
code0 = computeCode(x0, y0);
} else {
x1 = x;
y1 = y;
code1 = computeCode(x1, y1);
}
}
}
if (accept) {
glColor3f(0.0, 1.0, 0.0); // Set color to green for the accepted (clipped) line
glBegin(GL_LINES);
glVertex2f(x0, y0);
glVertex2f(x1, y1);
glEnd();
}
glColor3f(1.0, 0.0, 0.0); // Set color to red for the original unclipped line
glBegin(GL_LINES);
glVertex2f(25, 125);
glVertex2f(150, 250);
glEnd();
}
void display() {
glClear(GL_COLOR_BUFFER_BIT);
glColor3f(1.0, 0.0, 0.0); // Set color to red for the original unclipped line
glBegin(GL_LINES);
glVertex2f(x0, y0); // Original endpoints
glVertex2f(x1, y1);
glEnd();
cohenSutherlandLineClip();
glFlush();
}
int main(int argc, char **argv) {
glutInit(&argc, argv);
glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
glutInitWindowSize(400, 400);
glutCreateWindow("Cohen-Sutherland Line Clipping");
glClearColor(1.0, 1.0, 1.0, 1.0);
gluOrtho2D(0.0, 400.0, 0.0, 400.0);
glutDisplayFunc(display);
glutMainLoop();
return 0;
}
